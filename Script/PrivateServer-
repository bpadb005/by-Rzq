--[[


--HOW TO JOIN YOURSELF WITH ANOTHER ACCOUNT ON THE SERVER:


--Put this setclipboard at the end of the script below this one!!
setclipboard(accessCode)



--After you do that, run the script, it will copy the accessCode to clipboard, then use this small script below to join yourself ( add your accessCode first at local accessCode = "" )



--TELEPORT TO URSELF SCRIPT
local accesscode = "" -- paste your access code
local placeid = game.PlaceId

game.RobloxReplicatedStorage.ContactListIrisInviteTeleport:FireServer(placeid, "", accesscode)
    
]]

--PRIVATE SERVER CREATOR
local md5 = {}
local hmac = {}
local base64 = {}

do
	do
		local T = {
			0xd76aa478,
			0xe8c7b756,
			0x242070db,
			0xc1bdceee,
			0xf57c0faf,
			0x4787c62a,
			0xa8304613,
			0xfd469501,
			0x698098d8,
			0x8b44f7af,
			0xffff5bb1,
			0x895cd7be,
			0x6b901122,
			0xfd987193,
			0xa679438e,
			0x49b40821,
			0xf61e2562,
			0xc040b340,
			0x265e5a51,
			0xe9b6c7aa,
			0xd62f105d,
			0x02441453,
			0xd8a1e681,
			0xe7d3fbc8,
			0x21e1cde6,
			0xc33707d6,
			0xf4d50d87,
			0x455a14ed,
			0xa9e3e905,
			0xfcefa3f8,
			0x676f02d9,
			0x8d2a4c8a,
			0xfffa3942,
			0x8771f681,
			0x6d9d6122,
			0xfde5380c,
			0xa4beea44,
			0x4bdecfa9,
			0xf6bb4b60,
			0xbebfbc70,
			0x289b7ec6,
			0xeaa127fa,
			0xd4ef3085,
			0x04881d05,
			0xd9d4d039,
			0xe6db99e5,
			0x1fa27cf8,
			0xc4ac5665,
			0xf4292244,
			0x432aff97,
			0xab9423a7,
			0xfc93a039,
			0x655b59c3,
			0x8f0ccc92,
			0xffeff47d,
			0x85845dd1,
			0x6fa87e4f,
			0xfe2ce6e0,
			0xa3014314,
			0x4e0811a1,
			0xf7537e82,
			0xbd3af235,
			0x2ad7d2bb,
			0xeb86d391,
		}

		local function add(a, b)
			local lsw = bit32.band(a, 0xFFFF) + bit32.band(b, 0xFFFF)
			local msw = bit32.rshift(a, 16) + bit32.rshift(b, 16) + bit32.rshift(lsw, 16)
			return bit32.bor(bit32.lshift(msw, 16), bit32.band(lsw, 0xFFFF))
		end

		local function rol(x, n)
			return bit32.bor(bit32.lshift(x, n), bit32.rshift(x, 32 - n))
		end

		local function F(x, y, z)
			return bit32.bor(bit32.band(x, y), bit32.band(bit32.bnot(x), z))
		end
		local function G(x, y, z)
			return bit32.bor(bit32.band(x, z), bit32.band(y, bit32.bnot(z)))
		end
		local function H(x, y, z)
			return bit32.bxor(x, bit32.bxor(y, z))
		end
		local function I(x, y, z)
			return bit32.bxor(y, bit32.bor(x, bit32.bnot(z)))
		end

		function md5.sum(message)
			local a, b, c, d = 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476

			local message_len = #message
			local padded_message = message .. "\128"
			while #padded_message % 64 ~= 56 do
				padded_message = padded_message .. "\0"
			end

			local len_bytes = ""
			local len_bits = message_len * 8
			for i = 0, 7 do
				len_bytes = len_bytes .. string.char(bit32.band(bit32.rshift(len_bits, i * 8), 0xFF))
			end
			padded_message = padded_message .. len_bytes

			for i = 1, #padded_message, 64 do
				local chunk = padded_message:sub(i, i + 63)
				local X = {}
				for j = 0, 15 do
					local b1, b2, b3, b4 = chunk:byte(j * 4 + 1, j * 4 + 4)
					X[j] = bit32.bor(b1, bit32.lshift(b2, 8), bit32.lshift(b3, 16), bit32.lshift(b4, 24))
				end

				local aa, bb, cc, dd = a, b, c, d

				local s = { 7, 12, 17, 22, 5, 9, 14, 20, 4, 11, 16, 23, 6, 10, 15, 21 }

				for j = 0, 63 do
					local f, k, shift_index
					if j < 16 then
						f = F(b, c, d)
						k = j
						shift_index = j % 4
					elseif j < 32 then
						f = G(b, c, d)
						k = (1 + 5 * j) % 16
						shift_index = 4 + (j % 4)
					elseif j < 48 then
						f = H(b, c, d)
						k = (5 + 3 * j) % 16
						shift_index = 8 + (j % 4)
					else
						f = I(b, c, d)
						k = (7 * j) % 16
						shift_index = 12 + (j % 4)
					end

					local temp = add(a, f)
					temp = add(temp, X[k])
					temp = add(temp, T[j + 1])
					temp = rol(temp, s[shift_index + 1])

					local new_b = add(b, temp)
					a, b, c, d = d, new_b, b, c
				end

				a = add(a, aa)
				b = add(b, bb)
				c = add(c, cc)
				d = add(d, dd)
			end

			local function to_le_hex(n)
				local s = ""
				for i = 0, 3 do
					s = s .. string.char(bit32.band(bit32.rshift(n, i * 8), 0xFF))
				end
				return s
			end

			return to_le_hex(a) .. to_le_hex(b) .. to_le_hex(c) .. to_le_hex(d)
		end
	end

	do
		function hmac.new(key, msg, hash_func)
			if #key > 64 then
				key = hash_func(key)
			end

			local o_key_pad = ""
			local i_key_pad = ""
			for i = 1, 64 do
				local byte = (i <= #key and string.byte(key, i)) or 0
				o_key_pad = o_key_pad .. string.char(bit32.bxor(byte, 0x5C))
				i_key_pad = i_key_pad .. string.char(bit32.bxor(byte, 0x36))
			end

			return hash_func(o_key_pad .. hash_func(i_key_pad .. msg))
		end
	end

	do
		local b = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

		function base64.encode(data)
			return (
				(data:gsub(".", function(x)
					local r, b_val = "", x:byte()
					for i = 8, 1, -1 do
						r = r .. (b_val % 2 ^ i - b_val % 2 ^ (i - 1) > 0 and "1" or "0")
					end
					return r
				end) .. "0000"):gsub("%d%d%d?%d?%d?%d?", function(x)
					if #x < 6 then
						return ""
					end
					local c = 0
					for i = 1, 6 do
						c = c + (x:sub(i, i) == "1" and 2 ^ (6 - i) or 0)
					end
					return b:sub(c + 1, c + 1)
				end) .. ({ "", "==", "=" })[#data % 3 + 1]
			)
		end
	end
end

local function GenerateReservedServerCode(placeId)
	local uuid = {}
	for i = 1, 16 do
		uuid[i] = math.random(0, 255)
	end

	uuid[7] = bit32.bor(bit32.band(uuid[7], 0x0F), 0x40) -- v4
	uuid[9] = bit32.bor(bit32.band(uuid[9], 0x3F), 0x80) -- RFC 4122

	local firstBytes = ""
	for i = 1, 16 do
		firstBytes = firstBytes .. string.char(uuid[i])
	end

	local gameCode =
		string.format("%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x", table.unpack(uuid))

	local placeIdBytes = ""
	local pIdRec = placeId
	for _ = 1, 8 do
		placeIdBytes = placeIdBytes .. string.char(pIdRec % 256)
		pIdRec = math.floor(pIdRec / 256)
	end

	local content = firstBytes .. placeIdBytes

	local SUPERDUPERSECRETROBLOXKEYTHATTHEYDIDNTCHANGEEVERSINCEFOREVER = "e4Yn8ckbCJtw2sv7qmbg" -- legacy leaked key from ages ago that still works due to roblox being roblox.
	local signature = hmac.new(SUPERDUPERSECRETROBLOXKEYTHATTHEYDIDNTCHANGEEVERSINCEFOREVER, content, md5.sum)

	local accessCodeBytes = signature .. content

	local accessCode = base64.encode(accessCodeBytes)
	accessCode = accessCode:gsub("+", "-"):gsub("/", "_")

	local pdding = 0
	accessCode, _ = accessCode:gsub("=", function()
		pdding = pdding + 1
		return ""
	end)

	accessCode = accessCode .. tostring(pdding)

	return accessCode, gameCode
end

local accessCode, _ = GenerateReservedServerCode(game.PlaceId)
game.RobloxReplicatedStorage.ContactListIrisInviteTeleport:FireServer(game.PlaceId, "", accessCode)

--add setclipboard(accessCode) here

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

local md5 = {}
local hmac = {}
local base64 = {}

do
	do
		local T = {
			0xd76aa478,
			0xe8c7b756,
			0x242070db,
			0xc1bdceee,
			0xf57c0faf,
			0x4787c62a,
			0xa8304613,
			0xfd469501,
			0x698098d8,
			0x8b44f7af,
			0xffff5bb1,
			0x895cd7be,
			0x6b901122,
			0xfd987193,
			0xa679438e,
			0x49b40821,
			0xf61e2562,
			0xc040b340,
			0x265e5a51,
			0xe9b6c7aa,
			0xd62f105d,
			0x02441453,
			0xd8a1e681,
			0xe7d3fbc8,
			0x21e1cde6,
			0xc33707d6,
			0xf4d50d87,
			0x455a14ed,
			0xa9e3e905,
			0xfcefa3f8,
			0x676f02d9,
			0x8d2a4c8a,
			0xfffa3942,
			0x8771f681,
			0x6d9d6122,
			0xfde5380c,
			0xa4beea44,
			0x4bdecfa9,
			0xf6bb4b60,
			0xbebfbc70,
			0x289b7ec6,
			0xeaa127fa,
			0xd4ef3085,
			0x04881d05,
			0xd9d4d039,
			0xe6db99e5,
			0x1fa27cf8,
			0xc4ac5665,
			0xf4292244,
			0x432aff97,
			0xab9423a7,
			0xfc93a039,
			0x655b59c3,
			0x8f0ccc92,
			0xffeff47d,
			0x85845dd1,
			0x6fa87e4f,
			0xfe2ce6e0,
			0xa3014314,
			0x4e0811a1,
			0xf7537e82,
			0xbd3af235,
			0x2ad7d2bb,
			0xeb86d391,
			}

local function add(a, b)
	local lsw = bit32.band(a, 0xFFFF) + bit32.band(b, 0xFFFF)
	local msw = bit32.rshift(a, 16) + bit32.rshift(b, 16) + bit32.rshift(lsw, 16)
	return bit32.bor(bit32.lshift(msw, 16), bit32.band(lsw, 0xFFFF))
end

local function rol(x, n)
	return bit32.bor(bit32.lshift(x, n), bit32.rshift(x, 32 - n))
end

local function F(x, y, z)
	return bit32.bor(bit32.band(x, y), bit32.band(bit32.bnot(x), z))
end

local function G(x, y, z)
	return bit32.bor(bit32.band(x, z), bit32.band(y, bit32.bnot(z)))
end

local function H(x, y, z)
	return bit32.bxor(x, bit32.bxor(y, z))
end

local function I(x, y, z)
	return bit32.bxor(y, bit32.bor(x, bit32.bnot(z)))
end

function md5.sum(message)
	local a, b, c, d = 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476

	local message_len = #message
	local padded_message = message .. "\128"
	while #padded_message % 64 ~= 56 do
padded_message = padded_message .. "\0"
	end

	local len_bytes = ""
	local len_bits = message_len * 8
	for i = 0, 7 do
len_bytes = len_bytes .. string.char(bit32.band(bit32.rshift(len_bits, i * 8), 0xFF))
	end
	padded_message = padded_message .. len_bytes

	for i = 1, #padded_message, 64 do
local chunk = padded_message:sub(i, i + 63)
local X = {}
for j = 0, 15 do
	local b1, b2, b3, b4 = chunk:byte(j * 4 + 1, j * 4 + 4)
	X[j] = bit32.bor(b1, bit32.lshift(b2, 8), bit32.lshift(b3, 16), bit32.lshift(b4, 24))
end

local aa, bb, cc, dd = a, b, c, d

local s = { 7, 12, 17, 22, 5, 9, 14, 20, 4, 11, 16, 23, 6, 10, 15, 21 }

for j = 0, 63 do
	local f, k, shift_index
	if j < 16 then
f = F(b, c, d)
k = j
shift_index = j % 4
	elseif j < 32 then
f = G(b, c, d)
k = (1 + 5 * j) % 16
shift_index = 4 + (j % 4)
	elseif j < 48 then
f = H(b, c, d)
k = (5 + 3 * j) % 16
shift_index = 8 + (j % 4)
	else
f = I(b, c, d)
k = (7 * j) % 16
shift_index = 12 + (j % 4)
	end

	local temp = add(a, f)
	temp = add(temp, X[k])
	temp = add(temp, T[j + 1])
	temp = rol(temp, s[shift_index + 1])

	local new_b = add(b, temp)
	a, b, c, d = d, new_b, b, c
end

a = add(a, aa)
b = add(b, bb)
c = add(c, cc)
d = add(d, dd)
	end

	local function to_le_hex(n)
local s = ""
for i = 0, 3 do
	s = s .. string.char(bit32.band(bit32.rshift(n, i * 8), 0xFF))
end
return s
	end

	return to_le_hex(a) .. to_le_hex(b) .. to_le_hex(c) .. to_le_hex(d)
end
	end

	do
function hmac.new(key, msg, hash_func)
	if #key > 64 then
key = hash_func(key)
	end

	local o_key_pad = ""
	local i_key_pad = ""
	for i = 1, 64 do
local byte = (i <= #key and string.byte(key, i)) or 0
o_key_pad = o_key_pad .. string.char(bit32.bxor(byte, 0x5C))
i_key_pad = i_key_pad .. string.char(bit32.bxor(byte, 0x36))
	end

	return hash_func(o_key_pad .. hash_func(i_key_pad .. msg))
end
	end

	do
local b = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

function base64.encode(data)
	return (
(data:gsub(".", function(x)
	local r, b_val = "", x:byte()
	for i = 8, 1, -1 do
r = r .. (b_val % 2 ^ i - b_val % 2 ^ (i - 1) > 0 and "1" or "0")
	end
	return r
end) .. "0000"):gsub("%d%d%d?%d?%d?%d?", function(x)
	if #x < 6 then
return ""
	end
	local c = 0
	for i = 1, 6 do
c = c + (x:sub(i, i) == "1" and 2 ^ (6 - i) or 0)
	end
	return b:sub(c + 1, c + 1)
end) .. ({ "", "==", "=" })[#data % 3 + 1]
	)
end
	end
end

local function GenerateReservedServerCode(placeId)
	local uuid = {}
	for i = 1, 16 do
uuid[i] = math.random(0, 255)
	end

	uuid[7] = bit32.bor(bit32.band(uuid[7], 0x0F), 0x40) -- v4
	uuid[9] = bit32.bor(bit32.band(uuid[9], 0x3F), 0x80) -- RFC 4122

	local firstBytes = ""
	for i = 1, 16 do
firstBytes = firstBytes .. string.char(uuid[i])
	end

	local gameCode =
string.format("%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x", table.unpack(uuid))

	local placeIdBytes = ""
	local pIdRec = placeId
	for _ = 1, 8 do
placeIdBytes = placeIdBytes .. string.char(pIdRec % 256)
pIdRec = math.floor(pIdRec / 256)
	end

	local content = firstBytes .. placeIdBytes

	local SUPERDUPERSECRETROBLOXKEYTHATTHEYDIDNTCHANGEEVERSINCEFOREVER = "e4Yn8ckbCJtw2sv7qmbg" -- legacy leaked key from ages ago that still works due to roblox being roblox.
	local signature = hmac.new(SUPERDUPERSECRETROBLOXKEYTHATTHEYDIDNTCHANGEEVERSINCEFOREVER, content, md5.sum)

	local accessCodeBytes = signature .. content

	local accessCode = base64.encode(accessCodeBytes)
	accessCode = accessCode:gsub("+", "-"):gsub("/", "_")

	local pdding = 0
	accessCode, _ = accessCode:gsub("=", function()
pdding = pdding + 1
return ""
	end)

	accessCode = accessCode .. tostring(pdding)

	return accessCode, gameCode
end

local accessCode, _ = GenerateReservedServerCode(game.PlaceId)
game.RobloxReplicatedStorage.ContactListIrisInviteTeleport:FireServer(game.PlaceId, "", accessCode)

--add setclipboard(accessCode) here

---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

-- Rapikan implementasi MD5, HMAC, Base64 dan generator accessCode untuk Reserved Server Roblox
local md5 = {}
local hmac = {}
local base64 = {}

-- Constants untuk MD5 (T table)
local T = {
	0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
	0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
	0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
	0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
	0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
	0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
	0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
	0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391,
}

-- Utility helpers menggunakan bit32
local function add32(a, b)
	local lsw = bit32.band(a, 0xFFFF) + bit32.band(b, 0xFFFF)
	local msw = bit32.rshift(a, 16) + bit32.rshift(b, 16) + bit32.rshift(lsw, 16)
	return bit32.bor(bit32.lshift(msw, 16), bit32.band(lsw, 0xFFFF))
end

local function rol(x, n)
	return bit32.bor(bit32.lshift(x, n), bit32.rshift(x, 32 - n))
end

local function F(x, y, z) return bit32.bor(bit32.band(x, y), bit32.band(bit32.bnot(x), z)) end
local function G(x, y, z) return bit32.bor(bit32.band(x, z), bit32.band(y, bit32.bnot(z))) end
local function H(x, y, z) return bit32.bxor(x, bit32.bxor(y, z)) end
local function I(x, y, z) return bit32.bxor(y, bit32.bor(x, bit32.bnot(z))) end

-- MD5: mengembalikan 16-byte string (little-endian)
function md5.sum(message)
	local a, b, c, d = 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476

	-- Padding
	local message_len = #message
	local padded = message .. string.char(0x80)
	while #padded % 64 ~= 56 do
		padded = padded .. string.char(0)
	end

	-- Append original length in bits, little-endian 64-bit
	local len_bits = message_len * 8
	for i = 0, 7 do
		padded = padded .. string.char(bit32.band(bit32.rshift(len_bits, i * 8), 0xFF))
	end

	-- Process in 512-bit (64-byte) chunks
	local s = {7,12,17,22, 5,9,14,20, 4,11,16,23, 6,10,15,21}
	for i = 1, #padded, 64 do
		local chunk = padded:sub(i, i + 63)
		local X = {}
		for j = 0, 15 do
			local b1, b2, b3, b4 = chunk:byte(j * 4 + 1, j * 4 + 4)
			X[j] = bit32.bor(b1, bit32.lshift(b2, 8), bit32.lshift(b3, 16), bit32.lshift(b4, 24))
		end

		local aa, bb, cc, dd = a, b, c, d

		for j = 0, 63 do
			local f, k, shift_index
			if j < 16 then
				f = F(b, c, d)
				k = j
				shift_index = j % 4
			elseif j < 32 then
				f = G(b, c, d)
				k = (1 + 5 * j) % 16
				shift_index = 4 + (j % 4)
			elseif j < 48 then
				f = H(b, c, d)
				k = (5 + 3 * j) % 16
				shift_index = 8 + (j % 4)
			else
				f = I(b, c, d)
				k = (7 * j) % 16
				shift_index = 12 + (j % 4)
			end

			local temp = add32(a, f)
			temp = add32(temp, X[k])
			temp = add32(temp, T[j + 1])
			temp = rol(temp, s[shift_index + 1])

			local new_b = add32(b, temp)
			a, b, c, d = d, new_b, b, c
		end

		a = add32(a, aa)
		b = add32(b, bb)
		c = add32(c, cc)
		d = add32(d, dd)
	end

	-- Convert 4 x 32-bit words ke little-endian byte string
	local function to_le_bytes(n)
		local out = {}
		for i = 0, 3 do
			out[#out + 1] = string.char(bit32.band(bit32.rshift(n, i * 8), 0xFF))
		end
		return table.concat(out)
	end

	return to_le_bytes(a) .. to_le_bytes(b) .. to_le_bytes(c) .. to_le_bytes(d)
end

-- HMAC (menggunakan hash_func yang menerima string dan mengembalikan raw bytes)
function hmac.new(key, msg, hash_func)
	-- Jika key panjang > 64, hash dulu
	if #key > 64 then
		key = hash_func(key)
	end

	local o_key_pad = {}
	local i_key_pad = {}
	for i = 1, 64 do
		local byte = (i <= #key) and string.byte(key, i) or 0
		o_key_pad[i] = string.char(bit32.bxor(byte, 0x5C))
		i_key_pad[i] = string.char(bit32.bxor(byte, 0x36))
	end

	o_key_pad = table.concat(o_key_pad)
	i_key_pad = table.concat(i_key_pad)

	return hash_func(o_key_pad .. hash_func(i_key_pad .. msg))
end

-- Base64 encode (URL-safe later)
do
	local bchars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
	function base64.encode(data)
		-- Convert setiap char ke bit string, gabungkan, pad, lalu grup 6-bit
		local bitstr = (data:gsub(".", function(x)
			local byte = x:byte()
			local s = ""
			for i = 8, 1, -1 do
				s = s .. ((byte % 2 ^ i - byte % 2 ^ (i - 1) > 0) and "1" or "0")
			end
			return s
		end) .. "0000")

		local res = bitstr:gsub("%d%d%d?%d?%d?%d?", function(x)
			if #x < 6 then return "" end
			local c = 0
			for i = 1, 6 do
				if x:sub(i, i) == "1" then
					c = c + 2 ^ (6 - i)
				end
			end
			return bchars:sub(c + 1, c + 1)
		end)

		-- padding sesuai panjang asli
		local pad = ({ "", "==", "=" })[#data % 3 + 1]
		return res .. pad
	end
end

-- Generator Reserved Server Code (menghasilkan accessCode dan gameCode)
local function GenerateReservedServerCode(placeId)
	-- Buat 16-byte UUID acak
	local uuid = {}
	for i = 1, 16 do
		uuid[i] = math.random(0, 255)
	end

	-- Set versi dan variant sesuai UUID v4 / RFC 4122
	uuid[7] = bit32.bor(bit32.band(uuid[7], 0x0F), 0x40) -- version 4
	uuid[9] = bit32.bor(bit32.band(uuid[9], 0x3F), 0x80) -- variant

	-- firstBytes dari uuid (raw bytes)
	local firstBytes = {}
	for i = 1, 16 do firstBytes[i] = string.char(uuid[i]) end
	firstBytes = table.concat(firstBytes)

	-- gameCode (human-readable uuid hex)
	local gameCode = string.format(
		"%02x%02x%02x%02x-%02x%02x-%02x%02x-%02x%02x-%02x%02x%02x%02x%02x%02x",
		table.unpack(uuid)
	)

	-- placeId dalam 8-byte little-endian
	local placeIdBytes = {}
	local pIdRec = placeId
	for _ = 1, 8 do
		placeIdBytes[#placeIdBytes + 1] = string.char(pIdRec % 256)
		pIdRec = math.floor(pIdRec / 256)
	end
	placeIdBytes = table.concat(placeIdBytes)

	-- content = firstBytes .. placeIdBytes
	local content = firstBytes .. placeIdBytes

	-- Kunci legacy (tetap sama dengan skrip asli)
	local LEGACY_KEY = "e4Yn8ckbCJtw2sv7qmbg"

	-- signature: HMAC-MD5 (menggunakan md5.sum yang mengembalikan raw 16-byte)
	local signature = hmac.new(LEGACY_KEY, content, md5.sum)

	-- accessCodeBytes = signature || content
	local accessCodeBytes = signature .. content

	-- Base64 (URL-safe): ubah '+' -> '-' dan '/' -> '_', lalu tambahkan jumlah padding sebagai digit terakhir
	local accessCode = base64.encode(accessCodeBytes)
	accessCode = accessCode:gsub("+", "-"):gsub("/", "_")

	-- Hitung padding '=' yang dihilangkan dan letakkan jumlahnya sebagai digit akhir
	local paddingCount = 0
	accessCode = accessCode:gsub("=", function() paddingCount = paddingCount + 1; return "" end)
	accessCode = accessCode .. tostring(paddingCount)

	return accessCode, gameCode
end

-- Contoh pemakaian: kirim event ke server (sama seperti skrip asli)
local accessCode, _ = GenerateReservedServerCode(game.PlaceId)
game.RobloxReplicatedStorage.ContactListIrisInviteTeleport:FireServer(game.PlaceId, "", accessCode)

-- Jika ingin menyalin ke clipboard, tambahkan: setclipboard(accessCode)
